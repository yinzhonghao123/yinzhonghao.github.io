<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[移动端适配]]></title>
    <url>%2F783ce8a9.html</url>
    <content type="text"><![CDATA[#rem 适配 获取根元素html标签 用html.getBoundingClientRect().width获取他的视口大小 设置根元素的字体大小为视口大小/16 这样在任何一个设备上1rem的大小都是等比的 (function(){ var html = document.querySelector("html"); var width = html.getBoundingClientRect().width; html.style.fontSize=width/16+"px"; })(); #viewport适配 //获取图片的宽度 var tragetW =640; //获取整个视口的宽度 var width = document.documentElement.clientWidth; //定义一个比例 视口的宽度除以设计图的宽度 var scale = width/tragetW; //动态创建meta标签，使默认的缩放比例为这个比例 var metaNode = document.querySelector("meta[name='viewport']"); metaNode.setAttribute("content","width=device-width,initial-scale="+scale); ###一物理像素适配 (function(w){ //拿到对应设备的像素比 如果不存在则指定为1 var dpr = window.devicePixelRatio||1; var scale = 1/dpr; var rem = document.documentElement.clientWidth*dpr/16; //实现了页面所有元素的缩放 var metaNode = document.querySelector("meta[name='viewport']"); metaNode.setAttribute("content","width=device-width,initial-scale="+scale ); //将布局元素放大回来 var html = document.querySelector("html"); html.style.fontSize=rem+"px"; var styleNode = document.createElement("style"); styleNode.innerHTML="html{font-size:"+rem+"px!important}"; document.head.appendChild(styleNode); w.dpr=dpr; w.scale=scale; w.rem=rem; })(window) #sass适配 css初始化创建一个函数，其中 $px / 46.875&#39;中的数值是根据ui设计图和基于那个型号的手机做的设计图进行换算的 @function rem ( $px ) { @return $px / 46.875 + rem; } 使用的时候这样使用 要注意的是，这样可以不用带单位直接设计图多大尺寸，写进去自动换算成rem尺寸，单位不用带 h3 { font-size: rem(36); }]]></content>
      <tags>
        <tag>css</tag>
        <tag>移动端</tag>
        <tag>适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[highcharts图例控制]]></title>
    <url>%2F87ef91f6.html</url>
    <content type="text"><![CDATA[highcharts图表中图例的设置这个主要是控制所有图例的设置 123456789101112131415161718192021222324legend : &#123; backgroundColor : &apos;#ccc&apos; // 背景颜色 borderWidth : &apos;0&apos;, // 边框宽度 borderRadius : 0, // 边框圆角 borderColor : &apos;red&apos;, // 边框颜色 enabled : true, // 图例开关 layout : &apos;horizontal&apos; // 图例布局类型，默认horizontal 水平布局，垂直布局vertical // 图例点击后颜色 itemHiddenStyle : &#123; color : &apos;red&apos; &#125; // 鼠标放上样式 itemHoverStyle : &#123; color : &apos;red&apos; &#125; symbolPadding : 5 // 图标跟文字的间距 symbolPadding: // 图标后距 symbolRadius: // 图标圆角 symbolWidth: // 图标宽度&#125; 控制单个图例的显示和隐藏，就是默认状态为点击之后的隐藏状态 指定数据列的 visible 属性即可，示例代码： 123456789series: [&#123; name: &apos;series1&apos;, data: [], visible: true // 默认值&#125;,&#123; name: &apos;series2&apos;, data: [], visible: false // 不显示&#125;]]]></content>
      <tags>
        <tag>css</tag>
        <tag>js</tag>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[盒模型]]></title>
    <url>%2Ffdff8ae1.html</url>
    <content type="text"><![CDATA[看到好多关于盒模型的东西上个图 盒模型包括：content，padding，border，margin ie下为怪异盒模型，他的宽度获取为content+padding+border 普通浏览器的width获取值为content内容区的宽度 可以使用box-sizing 有两个值一个是content-box，另一个是border-box。 当设置为box-sizing:content-box时，将采用标准模式解析计算，也是默认模式； 当设置为box-sizing:border-box时，将采用怪异模式解析计算； 目前使用此属性需要前缀如下: -webkit-box-sizing: content-box; -moz-box-sizing: content-box;]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES5 ES6 ES7]]></title>
    <url>%2F4e6bf8ed.html</url>
    <content type="text"><![CDATA[理解ES 全称: ECMAScript js语言的规范 我们用的js是它的实现 js的组成 ECMAScript(js基础) 扩展–&gt;浏览器端 BOM DOM 扩展–&gt;服务器端 Node.js ES5 1.严格模式 运行模式: 正常(混杂)模式与严格模式 应用上严格式: ‘strict mode’; 作用: (简而言之，让语言更优雅，更严谨，更合理) 使得Javascript在更严格的条件下运行 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为 消除代码运行的一些不安全之处，保证代码运行的安全 需要记住的几个变化 声明定义变量必须用var 禁止函数中的this关键字指向全局对象 创建eval作用域, 更安全 2.JSON对象 本质：有特定结构的字符串 why：承载数据只能是字符串，为了更清晰展示，让数据有一定结构，使用了json where ：用于服务器和前端数据交互 作用: 用于在json对象/数组与js对象/数组相互转换 JSON.stringify(obj/arr) js对象(数组)转换为json对象(数组) JSON.parse(json) json对象(数组)转换为js对象(数组)*备注‘[{}]’或者‘{[]}’内部{},[]不需要加&quot;&quot;，函数不能转JSON 3.Object扩展 Object.create(prototype[, descriptors]) : 创建一个新的对象 以指定对象为原型创建新的对象 指定新的属性, 并对属性进行描述 value : 指定值 writable : 标识当前属性值是否是可修改的, 默认为true get方法 : 用来得到当前属性值的回调函数, 当读取当前属性值时自动调用 (newvalue)方法 : 用来监视当前属性值变化的回调函数, 当更新当前属性的值时(已经)自动调用 vue 框架的双向数据绑定与这个类似 Object.defineProperties(object, descriptors) : 为指定对象定义扩展多个属性 4.Array扩展 Array.prototype.indexOf(value) : 得到值在数组中的第一个下标 Array.prototype.lastIndexOf(value) : 得到值在数组中的最后一个下标 Array.prototype.forEach(function(item, index){}) : 遍历数组 when：遍历数组某一个元素时，调用回调函数 ，将元素本省和下标传进来 返回符合要求的数组项，组装成新数组返回 Array.prototype.map(function(item, index){ return xxx}) : 遍历数组返回一个原来长度的新数组 Array.prototype.filter(function(item, index){return true/false}) : 遍历过滤出一个为true的子数组 5.Function扩展 Function.prototype.bind(obj) 将函数内的this绑定为obj, 并将函数返回 面试题: 区别bind()与call()和apply()? fn.call(obj)和fn.call(obj) : 指定函数中的this,第二个参数不同，call参数是逗号隔开，apply是数组 fn.bind(obj) : 将函数内的this绑定为obj, 并返回函数，call和apply都是调用函数 6.Date扩展 Date.now() : 得到当前时间值 ES6 1.2个新的关键字 let/const 块作用域 没有变量提升 不能重复定义 值不可变 2.变量的解构赋值 将包含多个数据的对象(数组)一次性结构出来赋值给多个变量 let {n, a} = {n:’tom’, a:12} consle.log({n, a} ) 数据源: 对象/数组 目标: {a, b}/[a, b] 用途 给多个形参赋值 交换2个变量的值 3.各种数据类型的扩展 字符串 模板字符串 作用: 简化字符串的拼接 模板字符串必须用 变化的部分使用${xxx}定义* contains(str) : 判断是否包含指定的字符串 startsWith(str) : 判断是否以指定字符串开头 endsWith(str) : 判断是否以指定字符串结尾 repeat(count) : 重复指定次数 对象 简化的对象写法 Object.assign(target, source1, source2..): 将源对象的属性复制到目标对象上 Object.is(v1, v2) : 判断2个数据是否完全相等 proto属性 : 可以操作隐式原型属性 let name = ‘Tom’; let age = 12; *let person = { name, age, setName (name) { this.name = name; }*}; 数组 Array.from(v) : 将伪数组对象或可遍历对象转换为真数组 Array.of(v1, v2, v3) : 将一系列值转换成数组 find(function(value, index, arr){return true}) : 找出第一个满足条件返回true的元素 findIndex(function(value, index, arr){return true}) : 找出第一个满足条件返回true的元素下标 函数 箭头函数 用来定义匿名函数 基本语法: 没有参数: () =&gt; console.log(&#39;xxxx&#39;) 一个参数:i =&gt; i + 2 大于一个参数: (i, j) =&gt; i + j 不想return用大括号{} 默认返回结果 函数体如果有多个语句, 需要用{}包围 使用场景: 多用来定义回调函数 形参的默认值*function Point(x = 1,y = 2) { this.x = x; this.y = y;*} 定义形参时指定其默认的值 rest(可变)参数 通过形参左侧的…来表达, 取代arguments的使用*function add(…values) { let sum = 0; for(value of values) { sum += value; } return sum;*} 扩展运算符(…) 可以分解出数组或对象中的数据let arr1 = [1,3,5]; let arr2 = [2,…arr1,6];*arr2.push(…arr1); 4.set/Map容器结构 容器: 能保存多个数据的对象, 同时必须具备操作内部数据的方法 任意对象都可以作为容器使用, 但有的对象不太适合作为容器使用(如函数) Set的特点: 保存多个value, value是不重复 ====&gt;数组元素去重 Map的特点: 保存多个key–value, key是不重复, value是可以重复的 API Set()/Set(arr) //arr是一维数组 add(value) delete(value) clear(); has(value) size* Map()/Map(arr) //arr是二维数组 set(key, value) delete(key) clear() has(key) size 5.for–of循环 可以遍历任何容器 数组/伪数组 通过$(“”)获得jQuery对象 对象 伪/类对象 字符串 可迭代的对象 Promise 解决回调地狱(回调函数的层层嵌套, 编码是不断向右扩展, 阅读性很差) 能以同步编码的方式实现异步调用 在es6之前原生的js中是没这种实现的, 一些第三方框架(jQuery)实现了promise ES6中定义实现API:*// 1. 创建promise对象 var promise = new Promise(function(resolve, reject){ // 做异步的操作 if(成功) { // 调用成功的回调 resolve(result); } else { // 调用失败的回调 reject(errorMsg); } }) // 2. 调用promise对象的then() promise.then(function( result =&gt; console.log(result), errorMsg =&gt; alert(errorMsg) )) 7.class类 用 class 定义一类 用 constructor() 定义构造方法(相当于构造函数) 一般方法: xxx () {} 用extends来定义子类 用super()来父类的构造方法 方法重写: 将从父类中继承来的方法重新实现一遍 js中没有方法重载(方法名相同, 但参数不同)的语法 8.模块化 JS模块化 模块化的理解 什么是模块? 将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起 块的内部数据/实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信 一个模块的组成 数据—&gt;内部的属性 操作数据的行为—&gt;内部的函数 #####模块化 编码时是按照模块一个一个编码的, 整个项目就是一个模块化的项目 模块化的进化过程 #####全局function模式 : 编码: 全局变量/函数 问题: 污染全局命名空间, 容易引起命名冲突/数据不安全 #####namespace模式 : 编码: 将数据/行为封装到对象中 解决: 命名冲突(减少了全局变量) 问题: 数据不安全(外部可以直接修改模块内部的数据) #####IIFE模式/增强 IIFE : 立即调用函数表达式—&gt;匿名函数自调用 编码: 将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口 引入依赖: 通过函数形参来引入依赖模块 ES7 指数运算符: ** Array.prototype.includes(value) : 判断数组中是否包含指定value 区别方法的2种称谓 静态(工具)方法 Fun.xxx = function(){} 实例方法 所有实例对象 : Fun.prototype.xxx = function(){} //xxx针对Fun的所有实例对象 某个实例对象 : fun.xxx = function(){} //xxx只是针对fun对象]]></content>
      <tags>
        <tag>js</tag>
        <tag>es5</tag>
        <tag>es6</tag>
        <tag>es7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[haslayout]]></title>
    <url>%2F4b8b97c0.html</url>
    <content type="text"><![CDATA[什么是haslayoutlayout是windows IE的一个私有概念，它决定了元素如何对其内容定位和尺寸计算， 以及与其他元素的关系和相互作用。当一个元素“拥有布局”时，它会负责本身及其子元素的尺寸和定位。 而如果一个元素“没有拥有布局”，那么它的尺寸和位置由最近的拥有布局的祖先元素控制。 必须说明的是，IE8及以上浏览器使用了全新的显示引擎，已经不在使用haslayout属性， 因此haslayout属性只针对IE6和IE7。 为什么会有haslayout理论上说，每个元素都应该控制自己的尺寸和定位，即每个元素都应该“拥有布局”，当然这只是理想状态。 而对于早期的IE显示引擎来说，如果所有元素都“拥有布局”的话，会导致很大的性能问题。 因此IE开发团队决定使用布局概念来减少浏览器的性能开销，即只将布局应用于实际需要的那些元素， 所以便出现了“拥有布局”和“没有拥有布局”两种情况。 默认拥有布局的元素html, body, table, tr, td, img, hr, input, select, textarea, button, iframe, embed, object, applet, marquee 怎么触发haslayoutfloat: left或right display: inline-block position: absolute width: 除auto外任何值 height: 除auto外任何值 zoom: 除normal外任何值(zoom: 1无法在IE5.0中触发haslayout) writing-mode: tb-rl 在IE7中，以下属性也可以触发元素的haslayout min-height: 任意值 min-width: 任意值 max-height: 除none 外任意值 max-width: 除none 外任意值 overflow: 除visible外任意值，仅用于块级元素 overflow-x: 除visible 外任意值，仅用于块级元素 overflow-y: 除visible 外任意值，仅用于块级元素 position: fixed]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重绘&重排]]></title>
    <url>%2Ffa8505ef.html</url>
    <content type="text"><![CDATA[重绘(Repaint)重绘是一个元素外观的改变所触发的浏览器行为，例如改变outline、背景色等属性。浏览器会根据元素的新属性重新绘制， 使元素呈现新的外观。重绘不会带来重新布局，所以并不一定伴随重排。 重排(Reflow)渲染对象在创建完成并添加到渲染树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排 &quot;重绘&quot;不一定需要&quot;重排&quot;，比如改变某个网页元素的颜色，就只会触发&quot;重绘&quot;，不会触发&quot;重排&quot;，因为布局没有改变。 但是，&quot;重排&quot;必然导致&quot;重绘&quot;，比如改变一个网页元素的位置，就会同时触发&quot;重排&quot;和&quot;重绘&quot;，因为布局改变了。 常见的触发重排的操作Reflow 的成本比 Repaint 的成本高得多的多。DOM Tree 里的每个结点都会有 reflow 方法， 一个结点的 reflow 很有可能导致子结点，甚至父点以及同级结点的 reflow。在一些高性能的电脑上也许还没什么， 但是如果 reflow 发生在手机上，那么这个过程是非常痛苦和耗电的。 所以，下面这些动作有很大可能会是成本比较高的。 当你增加、删除、修改 DOM 结点时，会导致 Reflow , Repaint。 当你移动 DOM 的位置 当你修改 CSS 样式的时候。 当你 Resize 窗口的时候（移动端没有这个问题） 当你修改网页的默认字体时。 获取某些属性时 注：display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint， 因为没有发现位置变化。 注意当你请求向浏览器请求一些 style信息的时候，就会让浏览器flush队列，比如： 1. offsetTop, offsetLeft, offsetWidth, offsetHeight 2. scrollTop/Left/Width/Height 3. clientTop/Left/Width/Height 4. width,height 当你请求上面的一些属性的时候，浏览器为了给你最精确的值，需要flush队列， 因为队列中可能会有影响到这些值的操作。即使你获取元素的布局和样式信息跟最近的布局信息差不多， 浏览器都会强行刷新渲染队列。 优化1.将多次改变样式属性的操作合并成一次操作 2.将需要多次重排的元素，position属性设为absolute或fixed， 这样此元素就脱离了文档流，它的变化不会影响到其他元素。例如有动画效果的元素就最好设置为绝对定位。 3. 由于display属性为none的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排。 如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发2次重排。]]></content>
      <tags>
        <tag>css</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器兼容性]]></title>
    <url>%2Fe475da6d.html</url>
    <content type="text"><![CDATA[1.event事件对象兼容 event=event||window.event 2.event.x与event.y问题 问题说明：IE下，even对象有x、y属性，但是没有pageX、pageY属性； Firefox下，even对象有pageX、pageY属性，但是没有x、y属性。 解决方法：var myX = event.x ? event.x : event.pageX; var myY = event.y ? event.y:event.pageY; 如果考虑第8条问题，就改用myEvent代替event即可。 3.盒模型 盒模型包括：content，padding，border，margin ie下为怪异盒模型，他的宽度获取为content+padding+border 普通浏览器的width获取值为content内容区的宽度 可以使用box-sizing 有两个值一个是content-box，另一个是border-box。 当设置为box-sizing:content-box时，将采用标准模式解析计算，也是默认模式； 当设置为box-sizing:border-box时，将采用怪异模式解析计算； 目前使用此属性需要前缀如下: -webkit-box-sizing: content-box; -moz-box-sizing: content-box; 4.input属性placeholder IE8下不支持HTML5属性placeholder,可以使用插件进行解决 5.setAttribute(&apos;style&apos;,&apos;color:red;&apos;) FIREFOX支持(除了IE，现在所有浏览器都支持)，IE不支持 解决办法：不用setAttribute(&apos;style&apos;,&apos;color:red&apos;) 而用object.style.cssText = ‘color:red;&apos;(这写法也有例外) 最好的办法是上面种方法都用上，万无一失 6.监听事件 addEventListener支持除了ie的所有浏览器 attachEvent支持ie的监听事件，但是他的事件必须加上on 7.移除事件 ie浏览器中datachEvent进行移除事件 其他浏览器中使用removeEventListener进行移除事件 8.取消冒泡 取消冒泡 IE浏览器中使用cancelBuble=true来取消冒泡 普通浏览器中使用stopPropagation来禁止冒泡 9.禁止默认行为 IE浏览器中使用returnValue=&apos;false&apos;来禁止默认行为 普通浏览中使用preventDefault()来禁止默认行为 document.onclick=function(e){ var e=e||window.event; if (e.preventDefault) { e.preventDefault();//W3C标准 }else{ e.returnValue=&apos;false&apos;;//IE.. } } 10.关于EVENT事件中的target： //关于event事件中的target document.onmouseover=function(e){ var e=e||window.event; var Target=e.target||e.srcElement;//获取target的兼容写法，后面的为IE var from=e.relatedTarget||e.formElement;//鼠标来的地方，同样后面的为IE... var to=e.relatedTarget||e.toElement;//鼠标去的地方 } 11.鼠标滚轮滚动事件： //鼠标滚轮事件 //火狐中的滚轮事件 document.addEventListener(&quot;DOMMouseScroll&quot;,function(event){ alert(event.detail);//若前滚的话为 -3，后滚的话为 3 },false) //非火狐中的滚轮事件 document.onmousewheel=function(event){ alert(event.detail);//前滚：120，后滚：-120 } 12.ajax对象 IE浏览器中使用ActiveXObject创建ajax对象 普通浏览器中使用XmlHttprequest创建ajax对象]]></content>
      <tags>
        <tag>css</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js模块化]]></title>
    <url>%2F7b21deb9.html</url>
    <content type="text"><![CDATA[模块化的理解 什么是模块? 将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起 块的内部数据/实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信 一个模块的组成 数据—&gt;内部的变量 操作数据的行为—&gt;内部的函数 模块化 编码时是按照模块一个一个编码的, 整个项目就是一个模块化的项目 模块化的进化过程 全局function模式 : 编码: 全局变量/函数 问题: 污染全局命名空间, 容易引起命名冲突/数据不安全 namespace模式 : 编码: 将数据/行为封装到对象中 解决: 命名冲突(减少了全局变量) 问题: 数据不安全(外部可以直接修改模块内部的数据) IIFE模式/增强 IIFE : 立即调用函数表达式—&gt;匿名函数自调用 编码: 将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口 引入依赖: 通过函数形参来引入依赖模块123456789101112(function(window, module2)&#123; var data = &apos;atguigu.com&apos; function foo() &#123; module2.xxx() console.log(&apos;foo()&apos;+data) &#125; function bar() &#123; console.log(&apos;bar()&apos;+data) &#125; window.module = &#123;foo&#125;&#125;)(window, module2) JS模块化规范 CommonJS Node.js : 服务器端 Browserify : 浏览器端 也称为js的打包工具 基本语法: 定义暴露模块 : exports12exports.xxx = valuemodule.exports = value 引入模块 : require 1var module = require(&apos;模块名/模块相对路径&apos;) 引入模块发生在什么时候? Node : 运行时, 动态同步引入 Browserify : 在运行前对模块进行编译/转译/打包的处理(已经将依赖的模块包含进来了),运行的是打包生成的js, 运行时不存在需要再从远程引入依赖模块 AMD : 浏览器端 requireJS 基本语法 定义暴露模块: define([依赖模块名], function(){return 模块对象}) 引入模块: require([‘模块1’, ‘模块2’, ‘模块3’], function(m1, m2){//使用模块对象}) 配置:123456789101112131415161718192021require.config(&#123; //基本路径 baseUrl : &apos;js/&apos;, //标识名称与路径的映射 paths : &#123; &apos;模块1&apos; : &apos;modules/模块1&apos;, &apos;模块2&apos; : &apos;modules/模块2&apos;, &apos;angular&apos; : &apos;libs/angular&apos;, &apos;angular-messages&apos; : &apos;libs/angular-messages&apos; &#125;, //非AMD的模块 shim : &#123; &apos;angular&apos; : &#123; exports : &apos;angular&apos; &#125;, &apos;angular-messages&apos; : &#123; exports : &apos;angular-messages&apos;, deps : [&apos;angular&apos;] &#125; &#125;&#125;) CMD : 浏览器端 seaJS 基本语法 定义暴露模块: 12345define(function(require, module, exports)&#123; 通过require引入依赖模块 通过module/exports来暴露模块 exports.xxx = value&#125;) 使用模块seajs.use([‘模块1’, ‘模块2’]) ES6 ES6内置了模块化的实现 基本语法 定义暴露模块 : export 暴露一个对象: 1export default 对象 暴露多个: 123456export var xxx = value1export let yyy = value2 var xxx = value1let yyy = value2export &#123;xxx, yyy&#125; * 引入使用模块 : import * default模块: 1import xxx from &apos;模块路径/模块名&apos; * 其它模块 12import &#123;xxx, yyy&#125; from &apos;模块路径/模块名&apos;import * as module1 from &apos;模块路径/模块名&apos; * 问题: 所有浏览器还不能直接识别ES6模块化的语法 * 解决: * 使用Babel将ES6---&gt;ES5(使用了CommonJS) ----浏览器还不能直接支行 * 使用Browserify---&gt;打包处理----浏览器可以运行]]></content>
      <tags>
        <tag>js</tag>
        <tag>es5</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3 变量]]></title>
    <url>%2F1023f277.html</url>
    <content type="text"><![CDATA[一、支持范围 二、CSS变量var()语法和用法和特性 CSS中原生的变量定义语法是：--*，变量使用语法是：var(--*)，其中*表示我们的变量名称。 关于命名这个东西，各种语言都有些显示，例如CSS选择器不能是数字开头，JS中的变量是不能直接数值的，但是，在CSS变量中，这些限制通通没有, 例如： :root { --1: #369; } body { background-color: var(--1); } 另外值得注意的是 CSS 变量并不支持 !important 声明。 但是，不能包含$，[，^，(，%等字符，普通字符局限在只要是“数字[0-9]”“字母[a-zA-Z]”“下划线_”和“短横线-”这些组合，但是可以是中文，日文或者韩文，例如： body { --深蓝: #369; background-color: var(--深蓝); } 所以，我们就可以直接使用中文名称作为变量，即使英语4级没过的小伙伴也不会有压力了，我们也不需要随时挂个翻译器在身边了。 无论是变量的定义和使用只能在声明块{}里面，例如，下面这样是无效的： --深蓝: #369; body { background-color: var(--深蓝); } 变量的定义，或者说声明跟CSS计数器的声明类似的，你应该摆脱Sass/Less等预编译工具语法先入为主的语法影响，把CSS的原生变量理解为一种CSS属性。 这样，你就对其权重和变量应用规则要容易理解地多。 例如下面这个例子： :root { --color: purple; } div { --color: green; } #alert { --color: red; } * { color: var(--color); } 我的紫色继承于根元素 我的绿色来自直接设置 ID选择器权重更高，因此阿拉是红色！ 我也是红色，占了继承的光 上面这个例子我们可以获得这些信息： 1. 变量也是跟着CSS选择器走的，如果变量所在的选择器和使用变量的元素没有交集，是没有效果的。例如#alert定义的变量，只有id为alert的元素才能享有。如果你想变量全局使用，则你可以设置在:root选择器上； 2. 当存在多个同样名称的变量时候，变量的覆盖规则由CSS选择器的权重决定的，但并无!important这种用法，因为没有必要，!important设计初衷是干掉JS的style设置，但对于变量的定义则没有这样的需求。 如果我们使用的变量没有定义（注意，仅限于没有定义），则使用后面的值作为元素的属性值 .box { --1: #369; } body { background-color: var(--1, #cd0000); }]]></content>
      <tags>
        <tag>css</tag>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js事件节流]]></title>
    <url>%2F27adbae0.html</url>
    <content type="text"><![CDATA[鼠标的mousemove、scroll，浏览器窗口的resize事件等，都是在短时间内重复触发。 以onresize事件为例，若事件处理程序需要进行修改元素宽度高度等操作，那么频繁的触发事件会导致频繁的重绘页面。 DOM操作比非DOM交互需要更多的内存和CPU时间，连续尝试进行过多的DOM相关操作可能会导致浏览器挂起，有时候甚至会崩溃。 为了解决这个问题，需要使用定时器对该函数进行节流。 函数节流背后的基本思想是：某些代码不可以在没有间断的情况下连续重复执行。 第一次调用函数，创建一个定时器，在指定的时间间隔之后运行代码，当第二次调用函数时，它会清除前一次的定时器并设置另一个。如果前一次的定时器已经执行过了，这个操作就没有任何意义。 然而，如果前一个定时器尚未执行，其实就是将其替换成一个新的定时器。目的是只有在执行函数的请求停止了一段时间之后才执行。 throttle()函数：自动地进行定时器的设置和清除。接收两个参数：要执行的函数和在哪个作用域执行。 throttle()首先清除之前设置的任何定时器，定时器ID是存储在函数的tID属性中的，第一次把方法传递给throttle()函数的时候，这个属性可能并不存在。 接下来，创建一个新的定时器，并将其ID存储在方法的tID属性中。如果这是第一次对这个方法调用throttle()的话，那么这段代码就会创建该属性。定时器代码使用call()来确保方法在适当的环境中执行。 如果没有给出第二个参数，那么就在全局作用域内执行该方法。 时间间隔设为500ms，这表示监听鼠标的mousemove、scroll，浏览器窗口的resize等事件，事件处理函数会连续调用多次，但只在最后一次触发该事件。 节流函数主体 function throttle(method, context) { clearTimeout(method.tId); method.tId=setTimeout(function(){ method.call(context); },500); } 节流调取处理函数 var n = 1 function resizeHandler() { console.log(n); n++; } 调取节流函数 window.onresize = function(){ throttle(resizeHandler, window); // 或throttle(resizeHandler); };]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue中setTimeout值无效]]></title>
    <url>%2F623e7efa.html</url>
    <content type="text"><![CDATA[###解决Vue方法中setTimeout改变变量的值无效 把data里的变量继承过来重新封装一下 let that = this; this.rightAnswer = false; setTimeout(function() { that.rightAnswer = true; }, 1500)]]></content>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[属性描述符]]></title>
    <url>%2F7130c1f7.html</url>
    <content type="text"><![CDATA[对象属性的扩展使用.的形式动态添加（不可指定属性描述符） 使用Object.defineProperty的形式来添加（可以指定属性描述符） 获取对象属性的描述符Object.getOwnPropertyDescriptor(obj,&quot;name&quot;); 属性描述符writable：属性值的修改的权限 true：属性值是可以修改的 false：属性值是不可以修改的 默认情况下静默失败 严格模式下报错 configable：属性的重定义与删除权限 true：属性是可以重新定义和删除的 false：属性是不可以重新定义和删除的 默认情况和严格模式下都会报错 false情况下writable由true转成false是合理的,不会报错 emumerable：属性的枚举权限(能不能出现在for in循环中) true：属性是可以重新定义和删除的 false：属性是不可以重新定义和删除的 默认情况和严格模式下都会报错 set&amp;getget 方法控制着属性的读取操作 set 方法控制着属性的赋值操作 拥有get或set方法，或两者都有的属性，我们称之为访问描述符（与数据描述符相对应） 访问描述符与writable是会冲突的 不变性常量属性 将属性的writable和configurable设置为false 禁止属性的扩展 Object.preventExtensions(obj); 密封 Object.seal(obj) 在禁止对象扩展的基础上把现有属性的configurable都调整为false 冻结 Object.freeze(obj) 在密封对象的基础上把现有属性的writable都调整为false 注意 js所有的方法都只会影响对象的直接属性 判断枚举（不会遍历原型链）obj.propertyIsEnumerable(&quot;a&quot;) 获取对象所有的可枚举属性（不会遍历原型链）Object.keys(obj) 获取对象所有的属性（不会遍历原型链）obj.getOwnPropertyNames(&quot;a&quot;) 存在性检查(会遍历原型链)in操作符 (不会遍历原型链，只在对象中查找)obj.hasOwnProperty(&quot;a); 属性的查找1.在对象中查找是否具有相同名称的属性，如果找到，就会返回这个属性的值。 2.如果没有找到，则遍历原型链 3.无论·如何都没找到，返回undefined 属性的设置1.如果属性直接存在于对象中 不在原型链上 找到直接存在于对象中的属性 -数据描述符(没有setter/getter) 直接修改对象中的属性(注意writbale的值) -访问描述符 直接调用set方法 2.如果属性不直接存在于对象中也不在原型链上 在对象的直接属性中添加一个属性（数据描述符） value:&quot;a&quot; writable:true configurable:true enumerable:true 3.如果属性不直接存在于对象中 在原型链上 ①.该属性是数据描述符(没有setter/getter) -writbale为true 直接在对象中添加一个属性，我们称之为屏蔽属性 -writbale为false 报错，不会生成屏蔽属性 ②.该属性是访问描述符 调用set，不会生成屏蔽属性 4.如果属性直接存在于对象中 也在原型链上 找到直接存在于对象中的属性 -数据描述符(没有setter/getter) 直接修改对象中的属性(注意writbale的值) -访问描述符 直接调用set方法]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFC]]></title>
    <url>%2Fc5a97815.html</url>
    <content type="text"><![CDATA[在解释 BFC 是什么之前，需要先介绍 Box、Formatting Context的概念。Box: CSS布局的基本单位 Box 是 CSS 布局的对象和基本单位， 直观点来说，就是一个页面是由很多个 Box 组成的。 元素的类型和 display 属性，决定了这个 Box 的类型。 不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器）， 因此Box内的元素会以不同的方式渲染。让我们看看有哪些盒子： block-level box: display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context； inline-level box: display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。 并且参与 inline formatting context Formatting context Formatting context 是 W3C CSS2.1 规范中的一个概念。 它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。 最常见的 Formatting context 有 Block fomatting context (简称BFC) Inline formatting context (简称IFC)。 BFC是什么BFC(Block formatting context)直译为&quot;块级格式化上下文&quot;。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干 BFC布局规则：1.内部的Box会在垂直方向，一个接一个地放置。 2.内部的Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 3.每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 4.BFC的区域不会与float box重叠。 5.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 6.计算BFC的高度时，浮动元素也参与计算。 BFC什么时候出现(哪些元素会生成BFC?)根元素 float属性不为none position为absolute或fixed overflow不为visible display为inline-block, table-cell, table-caption, flex, inline-flex]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于头像]]></title>
    <url>%2Fa3efbd8f.html</url>
    <content type="text"><![CDATA[这个头像呢是因为孟二蛋才换的，看着喜庆，粗糙的表情😄]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
