<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>未卜的博客</title>
  
  <subtitle>code change the world !</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yinzhonghao123.github.io/"/>
  <updated>2018-03-14T01:36:07.556Z</updated>
  <id>http://yinzhonghao123.github.io/</id>
  
  <author>
    <name>未卜</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BFC</title>
    <link href="http://yinzhonghao123.github.io/BFC.html"/>
    <id>http://yinzhonghao123.github.io/BFC.html</id>
    <published>2018-03-13T02:15:42.000Z</published>
    <updated>2018-03-14T01:36:07.556Z</updated>
    
    <content type="html"><![CDATA[<h3 id="在解释-BFC-是什么之前，需要先介绍-Box、Formatting-Context的概念。"><a href="#在解释-BFC-是什么之前，需要先介绍-Box、Formatting-Context的概念。" class="headerlink" title="在解释 BFC 是什么之前，需要先介绍 Box、Formatting Context的概念。"></a>在解释 BFC 是什么之前，需要先介绍 Box、Formatting Context的概念。</h3><pre><code>Box: CSS布局的基本单位    Box 是 CSS 布局的对象和基本单位， 直观点来说，就是一个页面是由很多个 Box 组成的。    元素的类型和 display 属性，决定了这个 Box 的类型。 不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），    因此Box内的元素会以不同的方式渲染。让我们看看有哪些盒子：        block-level box:            display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context；        inline-level box:            display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。            并且参与 inline formatting contextFormatting context 　　        Formatting context 是 W3C CSS2.1 规范中的一个概念。        它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。        最常见的 Formatting context 有 Block fomatting context (简称BFC)                                    Inline formatting context (简称IFC)。</code></pre><a id="more"></a> <h3 id="BFC是什么"><a href="#BFC是什么" class="headerlink" title="BFC是什么"></a>BFC是什么</h3><pre><code>BFC(Block formatting context)直译为&quot;块级格式化上下文&quot;。它是一个独立的渲染区域，只有Block-level box参与，它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干</code></pre><h3 id="BFC布局规则："><a href="#BFC布局规则：" class="headerlink" title="BFC布局规则："></a>BFC布局规则：</h3><pre><code>1.内部的Box会在垂直方向，一个接一个地放置。2.内部的Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠3.每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。4.BFC的区域不会与float box重叠。5.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。6.计算BFC的高度时，浮动元素也参与计算。</code></pre><h3 id="BFC什么时候出现-哪些元素会生成BFC"><a href="#BFC什么时候出现-哪些元素会生成BFC" class="headerlink" title="BFC什么时候出现(哪些元素会生成BFC?)"></a>BFC什么时候出现(哪些元素会生成BFC?)</h3><pre><code>根元素float属性不为noneposition为absolute或fixedoverflow不为visibledisplay为inline-block, table-cell, table-caption, flex, inline-flex</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;在解释-BFC-是什么之前，需要先介绍-Box、Formatting-Context的概念。&quot;&gt;&lt;a href=&quot;#在解释-BFC-是什么之前，需要先介绍-Box、Formatting-Context的概念。&quot; class=&quot;headerlink&quot; title=&quot;在解释 BFC 是什么之前，需要先介绍 Box、Formatting Context的概念。&quot;&gt;&lt;/a&gt;在解释 BFC 是什么之前，需要先介绍 Box、Formatting Context的概念。&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;Box: CSS布局的基本单位
    Box 是 CSS 布局的对象和基本单位， 直观点来说，就是一个页面是由很多个 Box 组成的。
    元素的类型和 display 属性，决定了这个 Box 的类型。 不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），
    因此Box内的元素会以不同的方式渲染。让我们看看有哪些盒子：
        block-level box:
            display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context；
        inline-level box:
            display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。
            并且参与 inline formatting context

Formatting context 　　
        Formatting context 是 W3C CSS2.1 规范中的一个概念。
        它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。
        最常见的 Formatting context 有 Block fomatting context (简称BFC)
                                    Inline formatting context (简称IFC)。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="css" scheme="http://yinzhonghao123.github.io/categories/css/"/>
    
    
  </entry>
  
  <entry>
    <title>haslayout</title>
    <link href="http://yinzhonghao123.github.io/haslayout.html"/>
    <id>http://yinzhonghao123.github.io/haslayout.html</id>
    <published>2018-03-13T02:14:51.000Z</published>
    <updated>2018-03-14T01:36:07.558Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是haslayout"><a href="#什么是haslayout" class="headerlink" title="什么是haslayout"></a>什么是haslayout</h3><pre><code>layout是windows IE的一个私有概念，它决定了元素如何对其内容定位和尺寸计算，以及与其他元素的关系和相互作用。当一个元素“拥有布局”时，它会负责本身及其子元素的尺寸和定位。而如果一个元素“没有拥有布局”，那么它的尺寸和位置由最近的拥有布局的祖先元素控制。必须说明的是，IE8及以上浏览器使用了全新的显示引擎，已经不在使用haslayout属性，因此haslayout属性只针对IE6和IE7。</code></pre><a id="more"></a> <h3 id="为什么会有haslayout"><a href="#为什么会有haslayout" class="headerlink" title="为什么会有haslayout"></a>为什么会有haslayout</h3><pre><code>理论上说，每个元素都应该控制自己的尺寸和定位，即每个元素都应该“拥有布局”，当然这只是理想状态。而对于早期的IE显示引擎来说，如果所有元素都“拥有布局”的话，会导致很大的性能问题。因此IE开发团队决定使用布局概念来减少浏览器的性能开销，即只将布局应用于实际需要的那些元素，所以便出现了“拥有布局”和“没有拥有布局”两种情况。</code></pre><h3 id="默认拥有布局的元素"><a href="#默认拥有布局的元素" class="headerlink" title="默认拥有布局的元素"></a>默认拥有布局的元素</h3><pre><code>html, body, table, tr, td, img, hr,input, select, textarea, button,iframe, embed, object, applet, marquee</code></pre><h3 id="怎么触发haslayout"><a href="#怎么触发haslayout" class="headerlink" title="怎么触发haslayout"></a>怎么触发haslayout</h3><pre><code>float: left或rightdisplay: inline-blockposition: absolutewidth: 除auto外任何值height: 除auto外任何值zoom: 除normal外任何值(zoom: 1无法在IE5.0中触发haslayout)writing-mode: tb-rl在IE7中，以下属性也可以触发元素的haslayout    min-height: 任意值    min-width: 任意值    max-height: 除none 外任意值    max-width: 除none 外任意值    overflow: 除visible外任意值，仅用于块级元素    overflow-x: 除visible 外任意值，仅用于块级元素    overflow-y: 除visible 外任意值，仅用于块级元素    position: fixed</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是haslayout&quot;&gt;&lt;a href=&quot;#什么是haslayout&quot; class=&quot;headerlink&quot; title=&quot;什么是haslayout&quot;&gt;&lt;/a&gt;什么是haslayout&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;layout是windows IE的一个私有概念，它决定了元素如何对其内容定位和尺寸计算，
以及与其他元素的关系和相互作用。当一个元素“拥有布局”时，它会负责本身及其子元素的尺寸和定位。
而如果一个元素“没有拥有布局”，那么它的尺寸和位置由最近的拥有布局的祖先元素控制。

必须说明的是，IE8及以上浏览器使用了全新的显示引擎，已经不在使用haslayout属性，
因此haslayout属性只针对IE6和IE7。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="css" scheme="http://yinzhonghao123.github.io/categories/css/"/>
    
    
  </entry>
  
  <entry>
    <title>重绘&amp;重排</title>
    <link href="http://yinzhonghao123.github.io/%E9%87%8D%E7%BB%98&amp;%E9%87%8D%E6%8E%92.html"/>
    <id>http://yinzhonghao123.github.io/重绘&amp;重排.html</id>
    <published>2018-03-13T02:07:27.000Z</published>
    <updated>2018-03-14T01:36:36.675Z</updated>
    
    <content type="html"><![CDATA[<h3 id="重绘-Repaint"><a href="#重绘-Repaint" class="headerlink" title="重绘(Repaint)"></a>重绘(Repaint)</h3><pre><code>重绘是一个元素外观的改变所触发的浏览器行为，例如改变outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。重绘不会带来重新布局，所以并不一定伴随重排。</code></pre><a id="more"></a> <h3 id="重排-Reflow"><a href="#重排-Reflow" class="headerlink" title="重排(Reflow)"></a>重排(Reflow)</h3><pre><code>渲染对象在创建完成并添加到渲染树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排&quot;重绘&quot;不一定需要&quot;重排&quot;，比如改变某个网页元素的颜色，就只会触发&quot;重绘&quot;，不会触发&quot;重排&quot;，因为布局没有改变。 但是，&quot;重排&quot;必然导致&quot;重绘&quot;，比如改变一个网页元素的位置，就会同时触发&quot;重排&quot;和&quot;重绘&quot;，因为布局改变了。</code></pre><h3 id="常见的触发重排的操作"><a href="#常见的触发重排的操作" class="headerlink" title="常见的触发重排的操作"></a>常见的触发重排的操作</h3><pre><code>Reflow 的成本比 Repaint 的成本高得多的多。DOM Tree 里的每个结点都会有 reflow 方法，一个结点的 reflow 很有可能导致子结点，甚至父点以及同级结点的 reflow。在一些高性能的电脑上也许还没什么，但是如果 reflow 发生在手机上，那么这个过程是非常痛苦和耗电的。所以，下面这些动作有很大可能会是成本比较高的。    当你增加、删除、修改 DOM 结点时，会导致 Reflow , Repaint。    当你移动 DOM 的位置    当你修改 CSS 样式的时候。    当你 Resize 窗口的时候（移动端没有这个问题）    当你修改网页的默认字体时。    获取某些属性时    注：display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，        因为没有发现位置变化。</code></pre><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><pre><code>当你请求向浏览器请求一些 style信息的时候，就会让浏览器flush队列，比如：1. offsetTop, offsetLeft, offsetWidth, offsetHeight2. scrollTop/Left/Width/Height3. clientTop/Left/Width/Height4. width,height当你请求上面的一些属性的时候，浏览器为了给你最精确的值，需要flush队列，因为队列中可能会有影响到这些值的操作。即使你获取元素的布局和样式信息跟最近的布局信息差不多，浏览器都会强行刷新渲染队列。</code></pre><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><pre><code>1.将多次改变样式属性的操作合并成一次操作2.将需要多次重排的元素，position属性设为absolute或fixed，    这样此元素就脱离了文档流，它的变化不会影响到其他元素。例如有动画效果的元素就最好设置为绝对定位。3. 由于display属性为none的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排。    如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发2次重排。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;重绘-Repaint&quot;&gt;&lt;a href=&quot;#重绘-Repaint&quot; class=&quot;headerlink&quot; title=&quot;重绘(Repaint)&quot;&gt;&lt;/a&gt;重绘(Repaint)&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;重绘是一个元素外观的改变所触发的浏览器行为，例如改变outline、背景色等属性。浏览器会根据元素的新属性重新绘制，
使元素呈现新的外观。重绘不会带来重新布局，所以并不一定伴随重排。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="css" scheme="http://yinzhonghao123.github.io/categories/css/"/>
    
    
  </entry>
  
  <entry>
    <title>属性描述符</title>
    <link href="http://yinzhonghao123.github.io/%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6.html"/>
    <id>http://yinzhonghao123.github.io/属性描述符.html</id>
    <published>2018-03-13T01:57:39.000Z</published>
    <updated>2018-03-14T01:36:07.561Z</updated>
    
    <content type="html"><![CDATA[<h3 id="对象属性的扩展"><a href="#对象属性的扩展" class="headerlink" title="对象属性的扩展"></a>对象属性的扩展</h3><pre><code>使用.的形式动态添加（不可指定属性描述符）使用Object.defineProperty的形式来添加（可以指定属性描述符）</code></pre><a id="more"></a> <h3 id="获取对象属性的描述符"><a href="#获取对象属性的描述符" class="headerlink" title="获取对象属性的描述符"></a>获取对象属性的描述符</h3><pre><code>Object.getOwnPropertyDescriptor(obj,&quot;name&quot;);</code></pre><h3 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h3><pre><code>writable：属性值的修改的权限    true：属性值是可以修改的    false：属性值是不可以修改的            默认情况下静默失败            严格模式下报错configable：属性的重定义与删除权限    true：属性是可以重新定义和删除的    false：属性是不可以重新定义和删除的            默认情况和严格模式下都会报错            false情况下writable由true转成false是合理的,不会报错emumerable：属性的枚举权限(能不能出现在for in循环中)    true：属性是可以重新定义和删除的    false：属性是不可以重新定义和删除的            默认情况和严格模式下都会报错</code></pre><h3 id="set-amp-get"><a href="#set-amp-get" class="headerlink" title="set&amp;get"></a>set&amp;get</h3><pre><code>get 方法控制着属性的读取操作set 方法控制着属性的赋值操作拥有get或set方法，或两者都有的属性，我们称之为访问描述符（与数据描述符相对应）访问描述符与writable是会冲突的</code></pre><h3 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h3><pre><code>常量属性    将属性的writable和configurable设置为false禁止属性的扩展    Object.preventExtensions(obj);密封    Object.seal(obj)    在禁止对象扩展的基础上把现有属性的configurable都调整为false冻结    Object.freeze(obj)    在密封对象的基础上把现有属性的writable都调整为false注意    js所有的方法都只会影响对象的直接属性</code></pre><h3 id="判断枚举（不会遍历原型链）"><a href="#判断枚举（不会遍历原型链）" class="headerlink" title="判断枚举（不会遍历原型链）"></a>判断枚举（不会遍历原型链）</h3><pre><code>obj.propertyIsEnumerable(&quot;a&quot;)</code></pre><h3 id="获取对象所有的可枚举属性（不会遍历原型链）"><a href="#获取对象所有的可枚举属性（不会遍历原型链）" class="headerlink" title="获取对象所有的可枚举属性（不会遍历原型链）"></a>获取对象所有的可枚举属性（不会遍历原型链）</h3><pre><code>Object.keys(obj)</code></pre><h3 id="获取对象所有的属性（不会遍历原型链）"><a href="#获取对象所有的属性（不会遍历原型链）" class="headerlink" title="获取对象所有的属性（不会遍历原型链）"></a>获取对象所有的属性（不会遍历原型链）</h3><pre><code>obj.getOwnPropertyNames(&quot;a&quot;)</code></pre><h3 id="存在性检查"><a href="#存在性检查" class="headerlink" title="存在性检查"></a>存在性检查</h3><pre><code>(会遍历原型链)in操作符(不会遍历原型链，只在对象中查找)obj.hasOwnProperty(&quot;a);</code></pre><h3 id="属性的查找"><a href="#属性的查找" class="headerlink" title="属性的查找"></a>属性的查找</h3><pre><code>1.在对象中查找是否具有相同名称的属性，如果找到，就会返回这个属性的值。2.如果没有找到，则遍历原型链3.无论·如何都没找到，返回undefined</code></pre><h3 id="属性的设置"><a href="#属性的设置" class="headerlink" title="属性的设置"></a>属性的设置</h3><pre><code>1.如果属性直接存在于对象中　不在原型链上    找到直接存在于对象中的属性    -数据描述符(没有setter/getter)        直接修改对象中的属性(注意writbale的值)    -访问描述符        直接调用set方法2.如果属性不直接存在于对象中也不在原型链上    在对象的直接属性中添加一个属性（数据描述符）       value:&quot;a&quot;    writable:true    configurable:true    enumerable:true3.如果属性不直接存在于对象中  在原型链上    ①.该属性是数据描述符(没有setter/getter)        -writbale为true    直接在对象中添加一个属性，我们称之为屏蔽属性        -writbale为false        报错，不会生成屏蔽属性    ②.该属性是访问描述符        调用set，不会生成屏蔽属性4.如果属性直接存在于对象中  也在原型链上    找到直接存在于对象中的属性    -数据描述符(没有setter/getter)        直接修改对象中的属性(注意writbale的值)    -访问描述符        直接调用set方法</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;对象属性的扩展&quot;&gt;&lt;a href=&quot;#对象属性的扩展&quot; class=&quot;headerlink&quot; title=&quot;对象属性的扩展&quot;&gt;&lt;/a&gt;对象属性的扩展&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;使用.的形式动态添加（不可指定属性描述符）
使用Object.defineProperty的形式来添加（可以指定属性描述符）
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="js" scheme="http://yinzhonghao123.github.io/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>浏览器兼容性</title>
    <link href="http://yinzhonghao123.github.io/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7.html"/>
    <id>http://yinzhonghao123.github.io/浏览器兼容性.html</id>
    <published>2018-03-13T01:53:19.000Z</published>
    <updated>2018-03-14T01:36:07.553Z</updated>
    
    <content type="html"><![CDATA[<pre><code>1.event事件对象兼容    event=event||window.event</code></pre><a id="more"></a> <pre><code>2.event.x与event.y问题    问题说明：IE下，even对象有x、y属性，但是没有pageX、pageY属性；            Firefox下，even对象有pageX、pageY属性，但是没有x、y属性。    解决方法：var myX = event.x ? event.x : event.pageX;            var myY = event.y ? event.y:event.pageY;    如果考虑第8条问题，就改用myEvent代替event即可。3.盒模型    盒模型包括：content，padding，border，margin    ie下为怪异盒模型，他的宽度获取为content+padding+border    普通浏览器的width获取值为content内容区的宽度    可以使用box-sizing        有两个值一个是content-box，另一个是border-box。        当设置为box-sizing:content-box时，将采用标准模式解析计算，也是默认模式；        当设置为box-sizing:border-box时，将采用怪异模式解析计算；        目前使用此属性需要前缀如下:            -webkit-box-sizing: content-box;            -moz-box-sizing: content-box;4.input属性placeholder    IE8下不支持HTML5属性placeholder,可以使用插件进行解决5.setAttribute(&apos;style&apos;,&apos;color:red;&apos;)    FIREFOX支持(除了IE，现在所有浏览器都支持)，IE不支持    解决办法：不用setAttribute(&apos;style&apos;,&apos;color:red&apos;)        而用object.style.cssText = ‘color:red;&apos;(这写法也有例外)        最好的办法是上面种方法都用上，万无一失        6.监听事件    addEventListener支持除了ie的所有浏览器    attachEvent支持ie的监听事件，但是他的事件必须加上on7.移除事件        ie浏览器中datachEvent进行移除事件        其他浏览器中使用removeEventListener进行移除事件8.取消冒泡    取消冒泡        IE浏览器中使用cancelBuble=true来取消冒泡        普通浏览器中使用stopPropagation来禁止冒泡9.禁止默认行为    IE浏览器中使用returnValue=&apos;false&apos;来禁止默认行为    普通浏览中使用preventDefault()来禁止默认行为    document.onclick=function(e){        var e=e||window.event;        if (e.preventDefault) {          e.preventDefault();//W3C标准        }else{          e.returnValue=&apos;false&apos;;//IE..        }    }10.关于EVENT事件中的target：    //关于event事件中的target        document.onmouseover=function(e){            var e=e||window.event;            var Target=e.target||e.srcElement;//获取target的兼容写法，后面的为IE            var from=e.relatedTarget||e.formElement;//鼠标来的地方，同样后面的为IE...            var to=e.relatedTarget||e.toElement;//鼠标去的地方        }11.鼠标滚轮滚动事件：        //鼠标滚轮事件        //火狐中的滚轮事件        document.addEventListener(&quot;DOMMouseScroll&quot;,function(event){            alert(event.detail);//若前滚的话为 -3，后滚的话为 3        },false)        //非火狐中的滚轮事件        document.onmousewheel=function(event){            alert(event.detail);//前滚：120，后滚：-120        }12.ajax对象        IE浏览器中使用ActiveXObject创建ajax对象        普通浏览器中使用XmlHttprequest创建ajax对象</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;1.event事件对象兼容
    event=event||window.event
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>js模块化</title>
    <link href="http://yinzhonghao123.github.io/js%E6%A8%A1%E5%9D%97%E5%8C%96.html"/>
    <id>http://yinzhonghao123.github.io/js模块化.html</id>
    <published>2018-03-09T10:15:43.000Z</published>
    <updated>2018-03-14T01:36:07.547Z</updated>
    
    <content type="html"><![CDATA[<ul><li>模块化的理解</li><li>什么是模块?<ul><li>将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起</li><li>块的内部数据/实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信</li></ul></li><li>一个模块的组成<ul><li>数据—&gt;内部的变量</li><li>操作数据的行为—&gt;内部的函数</li></ul></li></ul><a id="more"></a> <ul><li>模块化<ul><li>编码时是按照模块一个一个编码的, 整个项目就是一个模块化的项目</li></ul></li><li><p>模块化的进化过程</p><ul><li>全局function模式 :<ul><li>编码: 全局变量/函数</li><li>问题: 污染全局命名空间, 容易引起命名冲突/数据不安全</li></ul></li><li>namespace模式 :<ul><li>编码: 将数据/行为封装到对象中</li><li>解决: 命名冲突(减少了全局变量)</li><li>问题: 数据不安全(外部可以直接修改模块内部的数据)</li></ul></li><li>IIFE模式/增强<ul><li>IIFE : 立即调用函数表达式—&gt;匿名函数自调用</li><li>编码: 将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口</li><li>引入依赖: 通过函数形参来引入依赖模块<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(function(window, module2)&#123;</span><br><span class="line">  var data = &apos;atguigu.com&apos;</span><br><span class="line">  function foo() &#123;</span><br><span class="line">     module2.xxx()</span><br><span class="line">     console.log(&apos;foo()&apos;+data)</span><br><span class="line">  &#125;</span><br><span class="line">  function bar() &#123;</span><br><span class="line">     console.log(&apos;bar()&apos;+data)</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  window.module = &#123;foo&#125;</span><br><span class="line">&#125;)(window, module2)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>JS模块化规范</p><ul><li><p>CommonJS</p><ul><li>Node.js : 服务器端</li><li>Browserify : 浏览器端    也称为js的打包工具</li><li><p>基本语法:</p><ul><li>定义暴露模块 : exports<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exports.xxx = value</span><br><span class="line">module.exports = value</span><br></pre></td></tr></table></figure></li></ul><p>引入模块 : require</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var module = require(&apos;模块名/模块相对路径&apos;)</span><br></pre></td></tr></table></figure></li><li><p>引入模块发生在什么时候?</p><ul><li>Node : 运行时, 动态同步引入</li><li>Browserify : 在运行前对模块进行编译/转译/打包的处理(已经将依赖的模块包含进来了),<br>运行的是打包生成的js, 运行时不存在需要再从远程引入依赖模块</li></ul></li></ul></li><li><p>AMD : 浏览器端</p><ul><li>requireJS</li><li>基本语法<ul><li>定义暴露模块: define([依赖模块名], function(){return 模块对象})</li><li>引入模块: require([‘模块1’, ‘模块2’, ‘模块3’], function(m1, m2){//使用模块对象})</li><li>配置:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">require.config(&#123;</span><br><span class="line">  //基本路径</span><br><span class="line">  baseUrl : &apos;js/&apos;,</span><br><span class="line">  //标识名称与路径的映射</span><br><span class="line">  paths : &#123;</span><br><span class="line">    &apos;模块1&apos; : &apos;modules/模块1&apos;,</span><br><span class="line">    &apos;模块2&apos; : &apos;modules/模块2&apos;,</span><br><span class="line">    &apos;angular&apos; : &apos;libs/angular&apos;,</span><br><span class="line">    &apos;angular-messages&apos; : &apos;libs/angular-messages&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  //非AMD的模块</span><br><span class="line">  shim : &#123;</span><br><span class="line">    &apos;angular&apos; : &#123;</span><br><span class="line">        exports : &apos;angular&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;angular-messages&apos; : &#123;</span><br><span class="line">        exports : &apos;angular-messages&apos;,</span><br><span class="line">        deps : [&apos;angular&apos;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>CMD : 浏览器端</p><ul><li>seaJS</li><li><p>基本语法</p><ul><li><p>定义暴露模块:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define(function(require, module, exports)&#123;</span><br><span class="line">  通过require引入依赖模块</span><br><span class="line">  通过module/exports来暴露模块</span><br><span class="line">  exports.xxx = value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>使用模块seajs.use([‘模块1’, ‘模块2’])</p></li></ul></li></ul></li><li><p>ES6</p><ul><li>ES6内置了模块化的实现</li><li><p>基本语法</p><ul><li><p>定义暴露模块 : export</p><ul><li><p>暴露一个对象:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export default 对象</span><br></pre></td></tr></table></figure></li><li><p>暴露多个:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export var xxx = value1</span><br><span class="line">export let yyy = value2</span><br><span class="line"> </span><br><span class="line">var xxx = value1</span><br><span class="line">let yyy = value2</span><br><span class="line">export &#123;xxx, yyy&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ul></li></ul><pre><code>  * 引入使用模块 : import    * default模块:      <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import xxx  from &apos;模块路径/模块名&apos;</span><br></pre></td></tr></table></figure>    * 其它模块      <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123;xxx, yyy&#125; from &apos;模块路径/模块名&apos;</span><br><span class="line">import * as module1 from &apos;模块路径/模块名&apos;</span><br></pre></td></tr></table></figure>* 问题: 所有浏览器还不能直接识别ES6模块化的语法 * 解决:    * 使用Babel将ES6---&gt;ES5(使用了CommonJS) ----浏览器还不能直接支行    * 使用Browserify---&gt;打包处理----浏览器可以运行</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;模块化的理解&lt;/li&gt;
&lt;li&gt;什么是模块?&lt;ul&gt;
&lt;li&gt;将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起&lt;/li&gt;
&lt;li&gt;块的内部数据/实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一个模块的组成&lt;ul&gt;
&lt;li&gt;数据—&amp;gt;内部的变量&lt;/li&gt;
&lt;li&gt;操作数据的行为—&amp;gt;内部的函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="js" scheme="http://yinzhonghao123.github.io/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>css3 变量</title>
    <link href="http://yinzhonghao123.github.io/css3%20%E5%8F%98%E9%87%8F.html"/>
    <id>http://yinzhonghao123.github.io/css3 变量.html</id>
    <published>2018-03-09T08:50:10.000Z</published>
    <updated>2018-03-14T01:36:07.560Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一、支持范围</p></blockquote><p><img src="/img/c3bl.png" alt="" title="描述"></p><a id="more"></a> <blockquote><p>二、CSS变量var()语法和用法和特性</p></blockquote><pre><code>CSS中原生的变量定义语法是：--*，变量使用语法是：var(--*)，其中*表示我们的变量名称。关于命名这个东西，各种语言都有些显示，例如CSS选择器不能是数字开头，JS中的变量是不能直接数值的，但是，在CSS变量中，这些限制通通没有,例如：</code></pre>   <pre>   <code>   :root {     --1: #369;   }   body {     background-color: var(--1);   }   </code>   </pre>    另外值得注意的是 CSS 变量并不支持 !important 声明。    但是，不能包含$，[，^，(，%等字符，普通字符局限在只要是“数字[0-9]”“字母[a-zA-Z]”“下划线_”和“短横线-”这些组合，但是可以是中文，日文或者韩文，例如：   <pre>      <code>        body {           --深蓝: #369;           background-color: var(--深蓝);        }      </code>   </pre><pre><code>所以，我们就可以直接使用中文名称作为变量，即使英语4级没过的小伙伴也不会有压力了，我们也不需要随时挂个翻译器在身边了。无论是变量的定义和使用只能在声明块{}里面，例如，下面这样是无效的：--深蓝: #369;</code></pre>   <pre>         <code>           body {                 background-color: var(--深蓝);               }         </code>   </pre><pre><code>变量的定义，或者说声明跟CSS计数器的声明类似的，你应该摆脱Sass/Less等预编译工具语法先入为主的语法影响，把CSS的原生变量理解为一种CSS属性。这样，你就对其权重和变量应用规则要容易理解地多。例如下面这个例子：</code></pre>   <pre>            <code>              :root { --color: purple; }                  div { --color: green; }                  #alert { --color: red; }                  * { color: var(--color); }                  <p>我的紫色继承于根元素</p>                      <div>我的绿色来自直接设置</div>                      <div id="alert">                        ID选择器权重更高，因此阿拉是红色！                        <p>我也是红色，占了继承的光</p>                      </div>            </code>      </pre><pre><code>上面这个例子我们可以获得这些信息：1. 变量也是跟着CSS选择器走的，如果变量所在的选择器和使用变量的元素没有交集，是没有效果的。例如#alert定义的变量，只有id为alert的元素才能享有。如果你想变量全局使用，则你可以设置在:root选择器上；2. 当存在多个同样名称的变量时候，变量的覆盖规则由CSS选择器的权重决定的，但并无!important这种用法，因为没有必要，!important设计初衷是干掉JS的style设置，但对于变量的定义则没有这样的需求。如果我们使用的变量没有定义（注意，仅限于没有定义），则使用后面的值作为元素的属性值</code></pre>   <pre>           <code>             .box {                   --1: #369;                 }                 body {                   background-color: var(--1, #cd0000);                 }           </code>     </pre>]]></content>
    
    <summary type="html">
    
      css3 变量
    
    </summary>
    
      <category term="css" scheme="http://yinzhonghao123.github.io/categories/css/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue中setTimeout值无效</title>
    <link href="http://yinzhonghao123.github.io/Vue%E4%B8%ADsetTimeout%E5%80%BC%E6%97%A0%E6%95%88.html"/>
    <id>http://yinzhonghao123.github.io/Vue中setTimeout值无效.html</id>
    <published>2018-03-09T08:28:40.000Z</published>
    <updated>2018-03-14T01:36:30.640Z</updated>
    
    <content type="html"><![CDATA[<p>###解决Vue方法中setTimeout改变变量的值无效</p><blockquote><p>把data里的变量继承过来重新封装一下<br>    <pre><br>        <code><br>        let that = this;<br>          this.rightAnswer = false;<br>          setTimeout(function() {<br>                that.rightAnswer = true;<br>          }, 1500)<br>          </code><br>    </pre></p></blockquote>]]></content>
    
    <summary type="html">
    
      解决Vue方法中setTimeout改变变量的值无效
    
    </summary>
    
      <category term="js" scheme="http://yinzhonghao123.github.io/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>js事件节流</title>
    <link href="http://yinzhonghao123.github.io/js%E4%BA%8B%E4%BB%B6%E8%8A%82%E6%B5%81.html"/>
    <id>http://yinzhonghao123.github.io/js事件节流.html</id>
    <published>2018-03-09T07:42:07.000Z</published>
    <updated>2018-03-14T01:36:07.543Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>鼠标的mousemove、scroll，浏览器窗口的resize事件等，都是在短时间内重复触发。</p></blockquote><blockquote><p>以onresize事件为例，若事件处理程序需要进行修改元素宽度高度等操作，那么频繁的触发事件会导致频繁的重绘页面。</p></blockquote><blockquote><p>DOM操作比非DOM交互需要更多的内存和CPU时间，连续尝试进行过多的DOM相关操作可能会导致浏览器挂起，有时候甚至会崩溃。</p></blockquote><blockquote><p>为了解决这个问题，需要使用定时器对该函数进行节流。</p></blockquote><a id="more"></a> <blockquote><p>函数节流背后的基本思想是：某些代码不可以在没有间断的情况下连续重复执行。</p></blockquote><blockquote><p>第一次调用函数，创建一个定时器，在指定的时间间隔之后运行代码，当第二次调用函数时，它会清除前一次的定时器并设置另一个。如果前一次的定时器已经执行过了，这个操作就没有任何意义。</p></blockquote><blockquote><p>然而，如果前一个定时器尚未执行，其实就是将其替换成一个新的定时器。目的是只有在执行函数的请求停止了一段时间之后才执行。</p></blockquote><blockquote><p>throttle()函数：自动地进行定时器的设置和清除。接收两个参数：要执行的函数和在哪个作用域执行。</p></blockquote><blockquote><p>throttle()首先清除之前设置的任何定时器，定时器ID是存储在函数的tID属性中的，第一次把方法传递给throttle()函数的时候，这个属性可能并不存在。</p></blockquote><blockquote><p>接下来，创建一个新的定时器，并将其ID存储在方法的tID属性中。如果这是第一次对这个方法调用throttle()的话，那么这段代码就会创建该属性。定时器代码使用call()来确保方法在适当的环境中执行。</p></blockquote><blockquote><p>如果没有给出第二个参数，那么就在全局作用域内执行该方法。</p></blockquote><blockquote><p>时间间隔设为500ms，这表示监听鼠标的mousemove、scroll，浏览器窗口的resize等事件，事件处理函数会连续调用多次，但只在最后一次触发该事件。</p></blockquote><blockquote><p>节流函数主体</p></blockquote><pre><code>function throttle(method, context) {       clearTimeout(method.tId);       method.tId=setTimeout(function(){           method.call(context);       },500);   } </code></pre><blockquote><p>节流调取处理函数</p></blockquote><pre><code>var n = 1 function resizeHandler() {       console.log(n);       n++;   }</code></pre><blockquote><p>调取节流函数</p></blockquote><pre><code>window.onresize = function(){      throttle(resizeHandler, window); // 或throttle(resizeHandler);  }; </code></pre>]]></content>
    
    <summary type="html">
    
      js事件节流
    
    </summary>
    
      <category term="js" scheme="http://yinzhonghao123.github.io/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>关于头像</title>
    <link href="http://yinzhonghao123.github.io/%E5%85%B3%E4%BA%8E%E5%A4%B4%E5%83%8F.html"/>
    <id>http://yinzhonghao123.github.io/关于头像.html</id>
    <published>2018-03-09T00:32:27.000Z</published>
    <updated>2018-03-14T01:36:07.551Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这个头像呢是因为孟二蛋才换的，看着喜庆，粗糙的表情😄<br><a id="more"></a> </p></blockquote><p><img src="/img/favicon.png" alt="" title="描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这个头像呢是因为孟二蛋才换的，看着喜庆，粗糙的表情😄&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
